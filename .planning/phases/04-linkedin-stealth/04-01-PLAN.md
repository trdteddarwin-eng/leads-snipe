---
phase: 04-linkedin-stealth
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - execution/linkedin_stealth.py
autonomous: true

must_haves:
  truths:
    - "DuckDuckGo search returns LinkedIn profile URLs for known names"
    - "System extracts name and title from LinkedIn search snippets"
    - "Bing fallback triggers when DDG fails or rate-limits"
    - "Invalid LinkedIn URLs (/company/, /jobs/) are filtered out"
  artifacts:
    - path: "execution/linkedin_stealth.py"
      provides: "LinkedIn stealth search via search engines"
      exports: ["search_duckduckgo", "search_bing", "parse_linkedin_snippet", "LinkedInResult"]
      min_lines: 150
  key_links:
    - from: "execution/linkedin_stealth.py"
      to: "duckduckgo-search library"
      via: "DDGS().text() method"
      pattern: "DDGS\\(\\)\\.text"
    - from: "execution/linkedin_stealth.py"
      to: "bing.com/search"
      via: "httpx GET request"
      pattern: "httpx.*bing\\.com/search"
---

<objective>
Build core LinkedIn stealth search capabilities using DuckDuckGo and Bing as search engines.

Purpose: Enable LinkedIn profile discovery without making direct requests to linkedin.com (avoiding rate limits and ToS issues)
Output: `execution/linkedin_stealth.py` with DDG search, Bing fallback, and snippet parsing
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@execution/linkedin_finder_unified.py (reference patterns: LINKEDIN_PROFILE_PATTERN, INVALID_USERNAMES)
</context>

<tasks>

<task type="auto">
  <name>Task 4.1: DuckDuckGo LinkedIn Search</name>
  <files>execution/linkedin_stealth.py</files>
  <action>
Create async DuckDuckGo search with LinkedIn URL extraction:

1. Define LinkedInResult dataclass with fields: linkedin_url, owner_name, owner_title, source, confidence
2. Define LINKEDIN_PROFILE_PATTERN regex matching linkedin.com/in/{username}/ (handle country codes, mobile)
3. Define INVALID_USERNAMES set: {'share', 'company', 'jobs', 'feed', 'in', 'posts', 'pulse', 'login'}
4. Implement async search_duckduckgo(name: str, company: str) -> Optional[dict]:
   - Build query: site:linkedin.com/in "{name}" "{company}"
   - Use DDGS().text() with backend="html", max_results=5
   - Run in executor for async compatibility (DDGS is sync)
   - Filter results to linkedin.com/in/ URLs only
   - Validate username against INVALID_USERNAMES
   - Return first valid result with href, title, body
5. Handle rate limits (202 errors) with exponential backoff
6. Use 2-3 second delays between requests

Use duckduckgo-search library (pip install duckduckgo-search).
Reference existing patterns from execution/linkedin_finder_unified.py lines 32-35 and 146.
  </action>
  <verify>python -c "from execution.linkedin_stealth import search_duckduckgo, LinkedInResult, LINKEDIN_PROFILE_PATTERN; import asyncio; print('DDG search imports OK'); assert LINKEDIN_PROFILE_PATTERN.match('https://linkedin.com/in/john-smith/')"</verify>
  <done>DDG search function exists, accepts name/company, returns dict with href/title/body or None. LINKEDIN_PROFILE_PATTERN regex validates profile URLs.</done>
</task>

<task type="auto">
  <name>Task 4.2: Snippet Name/Title Extraction</name>
  <files>execution/linkedin_stealth.py</files>
  <action>
Add snippet parsing for name and job title extraction:

1. Implement parse_linkedin_snippet(title: str, body: str) -> dict:
   - Returns {"name": str|None, "title": str|None}
2. Title format parsing:
   - Remove LinkedIn suffix (| LinkedIn, - LinkedIn)
   - Split by common delimiters (-, |)
   - First part = name (validate: 2+ words, reasonable length 3-50 chars)
   - Second part = title (if present)
3. Handle edge cases:
   - Dr./Jr./III suffixes in names
   - Commas in job titles
   - "at Company" format: "John Smith - Software Engineer at Company"
4. Return None for fields that cannot be reliably parsed
5. Never throw exceptions on malformed input

Example inputs/outputs:
- "John Smith - CEO - Company Inc | LinkedIn" -> {"name": "John Smith", "title": "CEO"}
- "John Smith | LinkedIn" -> {"name": "John Smith", "title": None}
- "Dr. Jane Doe - VP of Engineering | LinkedIn" -> {"name": "Dr. Jane Doe", "title": "VP of Engineering"}
  </action>
  <verify>python -c "from execution.linkedin_stealth import parse_linkedin_snippet; r = parse_linkedin_snippet('John Smith - CEO | LinkedIn', ''); assert r['name'] == 'John Smith', f'Got {r}'; assert r['title'] == 'CEO', f'Got {r}'; print('Snippet parsing OK')"</verify>
  <done>parse_linkedin_snippet extracts name and title from common LinkedIn snippet formats, returns None for unparseable fields, never throws on malformed input.</done>
</task>

<task type="auto">
  <name>Task 4.3: Bing Fallback Search</name>
  <files>execution/linkedin_stealth.py</files>
  <action>
Add Bing HTML scraping as fallback when DDG fails:

1. Implement async search_bing(name: str, company: str) -> Optional[dict]:
   - Build query: site:linkedin.com/in "{name}" "{company}"
   - URL: https://www.bing.com/search?q={query}&count=10
2. Use realistic headers to avoid bot detection:
   - User-Agent rotation (Chrome/Firefox variants)
   - Accept, Accept-Language headers
   - Referer: "https://www.bing.com/"
3. Parse HTML with BeautifulSoup:
   - Extract results from `li.b_algo` > `h2 a` elements
   - Get href, title text, snippet from each result
4. Filter to linkedin.com/in/ URLs only using LINKEDIN_PROFILE_PATTERN
5. Use 3-5 second delays (Bing is more aggressive on rate limiting)
6. Handle 403/CAPTCHA gracefully - return None, do not retry

Dependencies: httpx (existing), beautifulsoup4 (existing)
  </action>
  <verify>python -c "from execution.linkedin_stealth import search_bing; import asyncio; print('Bing search imports OK'); import inspect; sig = inspect.signature(search_bing); assert 'name' in sig.parameters and 'company' in sig.parameters"</verify>
  <done>Bing fallback search function exists, uses realistic headers, parses HTML results, returns dict with href/title/body or None on failure/block.</done>
</task>

</tasks>

<verification>
All three search/parse functions exist and are importable:

```bash
python -c "
from execution.linkedin_stealth import (
    search_duckduckgo,
    search_bing,
    parse_linkedin_snippet,
    LinkedInResult,
    LINKEDIN_PROFILE_PATTERN,
    INVALID_USERNAMES
)
print('All exports available')
print(f'Invalid usernames: {INVALID_USERNAMES}')
print(f'Pattern matches valid URL: {bool(LINKEDIN_PROFILE_PATTERN.match(\"https://linkedin.com/in/test-user/\"))}')
"
```
</verification>

<success_criteria>
1. search_duckduckgo accepts (name, company) and returns dict or None
2. search_bing accepts (name, company) and returns dict or None
3. parse_linkedin_snippet extracts name/title from "Name - Title | LinkedIn" format
4. LINKEDIN_PROFILE_PATTERN regex matches valid linkedin.com/in/ URLs
5. INVALID_USERNAMES filters out non-profile URLs
6. No direct linkedin.com requests in any function
</success_criteria>

<output>
After completion, create `.planning/phases/04-linkedin-stealth/04-01-SUMMARY.md`
</output>
